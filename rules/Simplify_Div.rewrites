// do not recompute bounds
//rewrite(IRMatcher::Overflow() / x, a),
//rewrite(x / IRMatcher::Overflow(), b),
rewrite(x / 1, x),
//(!op->type.is_float() && rewrite(x / 0, 0)),
//(!op->type.is_float() && denominator_non_zero && rewrite(x / x, 1)),
rewrite(0 / x, 0),

// do recompute bounds
rewrite(c0 / c1, fold(c0 / c1)),
rewrite(broadcast(x, c0) / broadcast(y, c0), broadcast(x / y, c0)),
rewrite(select(x, c0, c1) / c2, select(x, fold(c0/c2), fold(c1/c2)))

rewrite(x / x, select(x == 0, 0, 1)) |- !float,

// no_overflow
(rewrite((x / c0) / c2, x / fold(c0 * c2),                          c0 > 0 && c2 > 0 && !overflows(c0 * c2)),
  rewrite((x / c0 + c1) / c2, (x + fold(c1 * c0)) / fold(c0 * c2),   c0 > 0 && c2 > 0 && !overflows(c0 * c2) && !overflows(c0 * c1)),
  rewrite((x * c0) / c1, x / fold(c1 / c0),                          c1 % c0 == 0 && c0 > 0 && c1 / c0 != 0),
  // Pull out terms that are a multiple of the denominator
  rewrite((x * c0) / c1, x * fold(c0 / c1),                          c0 % c1 == 0 && c1 > 0),
  rewrite(min((x * c0), c1) / c2, min(x * fold(c0 / c2), fold(c1 / c2)), c0 % c2 == 0 && c2 > 0),
  rewrite(max((x * c0), c1) / c2, max(x * fold(c0 / c2), fold(c1 / c2)), c0 % c2 == 0 && c2 > 0),

  rewrite((x * c0 + y) / c1, y / c1 + x * fold(c0 / c1),             c0 % c1 == 0 && c1 > 0),
  rewrite((x * c0 - y) / c0, x + (0 - y) / c0),
  rewrite((x * c1 - y) / c0, (0 - y) / c0 - x,                       c0 + c1 == 0),
  rewrite((y + x * c0) / c1, y / c1 + x * fold(c0 / c1),             c0 % c1 == 0 && c1 > 0),
  rewrite((y - x * c0) / c1, y / c1 - x * fold(c0 / c1),             c0 % c1 == 0 && c1 > 0),

  rewrite(((x * c0 + y) + z) / c1, (y + z) / c1 + x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),
  rewrite(((x * c0 - y) + z) / c1, (z - y) / c1 + x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),
  rewrite(((x * c0 + y) - z) / c1, (y - z) / c1 + x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),
  rewrite(((x * c0 - y) - z) / c0, x + (0 - y - z) / c0),
  rewrite(((x * c1 - y) - z) / c0, (0 - y - z) / c0 - x,             c0 + c1 == 0),

  rewrite(((y + x * c0) + z) / c1, (y + z) / c1 + x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),
  rewrite(((y + x * c0) - z) / c1, (y - z) / c1 + x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),
  rewrite(((y - x * c0) - z) / c1, (y - z) / c1 - x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),
  rewrite(((y - x * c0) + z) / c1, (y + z) / c1 - x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),

  rewrite((z + (x * c0 + y)) / c1, (z + y) / c1 + x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),
  rewrite((z + (x * c0 - y)) / c1, (z - y) / c1 + x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),
  rewrite((z - (x * c0 - y)) / c1, (z + y) / c1 - x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),
  rewrite((z - (x * c0 + y)) / c1, (z - y) / c1 + x * fold(-c0 / c1), c0 % c1 == 0 && c1 > 0),

  rewrite((z + (y + x * c0)) / c1, (z + y) / c1 + x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),
  rewrite((z - (y + x * c0)) / c1, (z - y) / c1 + x * fold(-c0 / c1), c0 % c1 == 0 && c1 > 0),
  rewrite((z + (y - x * c0)) / c1, (z + y) / c1 - x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),
  rewrite((z - (y - x * c0)) / c1, (z - y) / c1 + x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),

  // For the next depth, stick to addition
  rewrite((((x * c0 + y) + z) + w) / c1, (y + z + w) / c1 + x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),
  rewrite((((y + x * c0) + z) + w) / c1, (y + z + w) / c1 + x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),
  rewrite(((z + (x * c0 + y)) + w) / c1, (y + z + w) / c1 + x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),
  rewrite(((z + (y + x * c0)) + w) / c1, (y + z + w) / c1 + x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),
  rewrite((w + ((x * c0 + y) + z)) / c1, (y + z + w) / c1 + x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),
  rewrite((w + ((y + x * c0) + z)) / c1, (y + z + w) / c1 + x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),
  rewrite((w + (z + (x * c0 + y))) / c1, (y + z + w) / c1 + x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0),
  rewrite((w + (z + (y + x * c0))) / c1, (y + z + w) / c1 + x * fold(c0 / c1), c0 % c1 == 0 && c1 > 0)) |- no_overflow,


// no_overflow_int

(rewrite((x + c0) / c1, x / c1 + fold(a_rem / c1 - (a_rem - c0) / c1), a_mod % c1 == 0),

rewrite((c0 - x)/c1, fold(a_rem / c1 + (c0 - a_rem) / c1) - x / c1, a_mod % c1 == 0),

// We can also pull it out when the constant is a
// multiple of the denominator.
rewrite((x + c0) / c1, x / c1 + fold(c0 / c1), c0 % c1 == 0),
rewrite((c0 - x) / c1, fold(c0 / c1) - x / c1, (c0 + 1) % c1 == 0)) |- no_overflow_int,

// denominator_non_zero
(rewrite((x + y)/x, y/x + 1),
rewrite((y + x)/x, y/x + 1),
rewrite((x - y)/x, (-y)/x + 1),
rewrite((y - x)/x, y/x - 1),
rewrite(((x + y) + z)/x, (y + z)/x + 1),
rewrite(((y + x) + z)/x, (y + z)/x + 1),
rewrite((z + (x + y))/x, (z + y)/x + 1),
rewrite((z + (y + x))/x, (z + y)/x + 1),
rewrite((x*y)/x, y),
rewrite((y*x)/x, y),
rewrite((x*y + z)/x, y + z/x),
rewrite((y*x + z)/x, y + z/x),
rewrite((z + x*y)/x, z/x + y),
rewrite((z + y*x)/x, z/x + y),
rewrite((x*y - z)/x, y + (-z)/x),
rewrite((y*x - z)/x, y + (-z)/x),
rewrite((z - x*y)/x, z/x - y),
rewrite((z - y*x)/x, z/x - y)) // |- denominator_non_zero

rewrite(x/c0, x * fold(1/c0)) |- float,

// no_overflow_int
(rewrite(ramp(x, c0, lanes) / broadcast(c1, lanes), ramp(x / c1, fold(c0 / c1), lanes), (c0 % c1 == 0)),
  rewrite(ramp(x, c0, lanes) / broadcast(c1, lanes), broadcast(x / c1, lanes),
  // First and last lanes are the same when...
  can_prove((x % c1 + c0 * (lanes - 1)) / c1 == 0, this))) |- no_overflow_int,

// no_overflow_scalar_int
(rewrite(x / -1, -x)
  // TODO: This also needs `denominator_non_zero`...
  // (denominator_non_zero && rewrite(c0 / y, select(y < 0, fold(-c0), c0), c0 == -1))
  rewrite((x * c0 + c1) / c2,
  (x + fold(c1 / c0)) / fold(c2 / c0),
  c2 > 0 && c0 > 0 && c2 % c0 == 0),
  rewrite((x * c0 + c1) / c2,
  x * fold(c0 / c2) + fold(c1 / c2),
  c2 > 0 && c0 % c2 == 0),
  // A very specific pattern that comes up in bounds in upsampling code.
  rewrite((x % 2 + c0) / 2, x % 2 + fold(c0 / 2), c0 % 2 == 1)) |- no_overflow_scalar_int
